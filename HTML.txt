<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>ç©ºé–“è¨­è¨ˆå°è¦½æ–‡æ¡ˆå°å¹«æ‰‹</title>
  <style>
    body { font-family: sans-serif; background-color: #fffbea; padding: 20px; }
    .card { background: #fff8e1; padding: 20px; border-radius: 12px; box-shadow: 2px 2px 10px rgba(0,0,0,0.1); }
    label { font-weight: bold; }
    input, select, textarea { width: 100%; padding: 8px; margin: 5px 0 15px 0; border-radius: 6px; border: 1px solid #ccc; }
    button { background-color: #ffcc80; border: none; padding: 10px 20px; border-radius: 8px; cursor: pointer; margin-right: 10px; }
    button:hover { background-color: #ffb74d; }
    img { max-width: 100%; margin-top: 10px; }
    .preview-block { background: #fff3e0; padding: 10px; margin-top: 10px; border-radius: 6px; white-space: pre-wrap; }
  </style>
</head>
<body>
  <div class="card">
    <h2>ğŸ  ç©ºé–“è¨­è¨ˆå°è¦½æ–‡æ¡ˆå°å¹«æ‰‹</h2>

    <label>ğŸ“· ä¸Šå‚³2Då¹³é¢åœ–ï¼ˆJPG / PNGï¼‰</label>
    <input type="file" id="floorplan" accept="image/png, image/jpeg" onchange="previewImage(event)">
    <img id="preview" style="max-height: 300px; object-fit: contain;" />

    <label>ğŸ“ ç¸½åªæ•¸ï¼ˆå¯é¸å¡«ï¼‰</label>
    <input type="number" id="total_area" placeholder="ä¾‹å¦‚ï¼š18.5">

    <label>ğŸ¨ è¨­è¨ˆé¢¨æ ¼</label>
    <select id="style" onchange="updateStyleInfo(this.value)">
      <option value="">è«‹é¸æ“‡é¢¨æ ¼</option>
      <option value="åŒ—æ­é¢¨">åŒ—æ­é¢¨</option><option value="æ—¥å¼ç¦ªé¢¨">æ—¥å¼ç¦ªé¢¨</option><option value="å·¥æ¥­é¢¨">å·¥æ¥­é¢¨</option>
      <option value="ç°¡ç´„é¢¨">ç°¡ç´„é¢¨</option><option value="æ··æ­é¢¨">æ··æ­é¢¨</option><option value="ç¾ä»£é¢¨">ç¾ä»£é¢¨</option>
      <option value="é„‰æ‘é¢¨">é„‰æ‘é¢¨</option><option value="å¤å…¸é¢¨">å¤å…¸é¢¨</option><option value="æ–°å¤å…¸é¢¨">æ–°å¤å…¸é¢¨</option>
      <option value="ç¾å¼é¢¨">ç¾å¼é¢¨</option><option value="åœ°ä¸­æµ·é¢¨">åœ°ä¸­æµ·é¢¨</option><option value="æ—¥å¼ç„¡å°é¢¨">æ—¥å¼ç„¡å°é¢¨</option>
      <option value="æ—¥å¼ä¾˜å¯‚é¢¨">æ—¥å¼ä¾˜å¯‚é¢¨</option>
    </select>
    <div id="style_feature" class="preview-block">é¢¨æ ¼ç‰¹è‰²ï¼šè«‹é¸æ“‡è¨­è¨ˆé¢¨æ ¼</div>

    <label>ğŸ‘¨â€ğŸ‘©â€ğŸ‘§ å±…ä½æˆå“¡</label>
    <input id="member" placeholder="ä¾‹å¦‚ï¼šå¤«å¦»ï¼‹åœ‹å°å¥³å…’ï¼‹ç°è²“">

    <label>ğŸ’¼ è·æ¥­</label>
    <input id="job" placeholder="ä¾‹å¦‚ï¼šå¤«å¦»çš†ç‚ºå…¬å‹™å“¡">

    <label>ğŸ¯ èˆˆè¶£èˆ‡ç”Ÿæ´»ç¿’æ…£</label>
    <input id="hobby" placeholder="ä¾‹å¦‚ï¼šæ‰“ç¾½æ¯›çƒã€çœ‹å½±é›†ã€æ”¶è—å…¬ä»”">

    <label>ğŸ“¦ ç©ºé–“ä¸»è¦éœ€æ±‚</label>
    <input id="need" placeholder="ä¾‹å¦‚ï¼šå¤§é‡æ”¶ç´ã€å¯µç‰©å…±å±…ã€é–±è®€ç©ºé–“">
    <button onclick="analyzeFurniture()">ğŸ“Š åˆ†æç©ºé–“èˆ‡å®¶å…·é…ç½®</button>

    <p id="status"></p>
    <div id="furniturePreview" class="preview-block"></div>
        
    <label>âœï¸ å®¶å…·é…ç½®ä¿®æ­£ï¼ˆå¯è£œå……ï¼ä¿®æ­£åŸå§‹è¾¨è­˜ï¼‰</label>
    <textarea id="furniture_correction" rows="6" placeholder="ä¾‹å¦‚ï¼šä¸»è‡¥å¢åŠ åºŠé ­æ«ƒ2å€‹ï¼Œå®¢å»³åŸæœ¬æ²™ç™¼è¾¨è­˜éŒ¯èª¤ç‚ºæ›¸æ«ƒ" style="width:100%; margin-top:5px;"></textarea>
    <div style="background:#fff3e0; padding:8px 12px; margin-top:5px; font-size: 13px; line-height: 1.6; border-radius: 6px; color:#333;">
      ä¾‹å¦‚ï¼šä¸»è‡¥å®¤å¢åŠ åºŠé ­æ«ƒ2å€‹ï¼Œå®¢å»³åˆªé™¤èŒ¶å‡ ï¼Œæ›¸æˆ¿åªæ•¸æ”¹ç‚º3.2ï¼Œé¤å»³æ¸…ç©ºå®¶å…·ï¼Œæ–°å¢é™½å° 1.5åªï¼Œå®¶å…·ï¼šæ´—è¡£æ©Ÿã€æ›¬è¡£æ¶ï¼Œä¸»è‡¥å®¤å°‡åºŠé ­æ«ƒæ”¹ç‚ºåºŠé ­æ«ƒ3å€‹ï¼Œä¸»è‡¥å®¤æ”¹åç‚ºå¤«å¦»æˆ¿ï¼Œåˆªé™¤å¤šåŠŸèƒ½æˆ¿
      <br><span style="font-size: 12px; color: #777;">æ¯å¥è«‹ç”¨é “è™Ÿã€é€—è™Ÿæˆ–æ›è¡Œåˆ†éš”å¾Œé»æ“Šã€ŒğŸ” æ›´æ–°å®¶å…·é…ç½®é è¦½ã€æŒ‰éˆ•</span>
    </div>

    <button onclick="applyFurnitureCorrection()">ğŸ” æ›´æ–°å®¶å…·é…ç½®é è¦½</button>
    <button onclick="submitForm()">ğŸ“ ç”¢å‡ºå°è¦½æ–‡æ¡ˆ</button>
    <div id="docPreview" class="preview-block">ğŸ“ æ–‡æ¡ˆé è¦½å€å°‡é¡¯ç¤ºæ–¼æ­¤</div>
    <button id="downloadWord" onclick="downloadWordDoc()" style="display:none;">ğŸ“„ ä¸‹è¼‰ Word æ–‡æ¡ˆ</button>
  </div>

  <script>
    const styleFeatureMap = {
      "åŒ—æ­é¢¨": "æ¸…æ–°è‡ªç„¶ç°¡ç´„", "æ—¥å¼ç¦ªé¢¨": "éœè¬ç•™ç™½ç¦ªæ„", "å·¥æ¥­é¢¨": "ç²—ç·æ°´æ³¥é‡‘å±¬",
      "ç°¡ç´„é¢¨": "ç·šæ¢æ¸…çˆ½å¯¦ç”¨", "æ··æ­é¢¨": "ç•°æè‡ªç”±çµ„åˆ", "ç¾ä»£é¢¨": "ä¿è½ç§‘æŠ€è³ªæ„Ÿ",
      "é„‰æ‘é¢¨": "æº«é¦¨è‡ªç„¶æœ¨è³ª", "å¤å…¸é¢¨": "å°ç¨±é›•é£¾å±¤æ¬¡", "æ–°å¤å…¸é¢¨": "å„ªé›…ç¾ä»£èåˆ",
      "ç¾å¼é¢¨": "èˆ’é©å¤§å™¨å±…å®¶", "åœ°ä¸­æµ·é¢¨": "è—ç™½æ‹±é–€æ›²ç·š", "æ—¥å¼ç„¡å°é¢¨": "æ¨¸ç´ æº«æ½¤æœ¨è‰²",
      "æ—¥å¼ä¾˜å¯‚é¢¨": "ç°èª¿ç•™ç™½æ™‚é–“æ„Ÿ"
    };

    function updateStyleInfo(style) {
      document.getElementById("style_feature").textContent = "é¢¨æ ¼ç‰¹è‰²ï¼š" + (styleFeatureMap[style] || "è«‹é¸æ“‡è¨­è¨ˆé¢¨æ ¼");
    }

    function previewImage(event) {
      const reader = new FileReader();
      reader.onload = function(){
        document.getElementById("preview").src = reader.result;
      };
      reader.readAsDataURL(event.target.files[0]);
    }

    async function analyzeFurniture() {
      const fileInput = document.getElementById("floorplan");
      const status = document.getElementById("status");
      const furniturePreview = document.getElementById("furniturePreview");

      if (!fileInput.files.length) {
        status.textContent = "è«‹å…ˆä¸Šå‚³åœ–é¢";
        return;
      }

      status.textContent = "ğŸ“¤ æ­£åœ¨åˆ†æåœ–é¢...";
      const formData = new FormData();
      formData.append("file", fileInput.files[0]);

      const parseRes = await fetch("https://interior-indoortour-ai.onrender.com/api/parse_floorplan", { method: "POST", body: formData });
      const parsed = await parseRes.json();
      window.latestParsedFurniture = parsed.spaces;

      if (parsed.spaces && parsed.spaces.length > 0) {
        renderFurnitureTable(parsed.spaces);
      } else {
        furniturePreview.innerText = "âŒ ç„¡æ³•è¾¨è­˜ç©ºé–“èˆ‡å®¶å…·é…ç½®";
      }
      status.textContent = "âœ… åˆ†æå®Œæˆï¼Œè«‹ç¹¼çºŒç”¢å‡ºå°è¦½æ–‡æ¡ˆã€‚";
    }

    async function submitForm() {
      const fileInput = document.getElementById("floorplan");
      const totalArea = document.getElementById("total_area").value;
      const style = document.getElementById("style").value;
      const owner_info = 
        "å±…ä½æˆå“¡ï¼š" + document.getElementById("member").value + "\n" +
        "è·æ¥­ï¼š" + document.getElementById("job").value + "\n" +
        "èˆˆè¶£ï¼š" + document.getElementById("hobby").value + "\n" +
        "éœ€æ±‚ï¼š" + document.getElementById("need").value;
      const status = document.getElementById("status");

      if (!fileInput.files.length) {
        status.textContent = "è«‹ä¸Šå‚³åœ–é¢";
        return;
      }

      status.textContent = "ğŸ§  æ­£åœ¨ç”¢å‡ºæ–‡æ¡ˆ...";

      // **é—œéµä¿®æ­£**ï¼šä¸è«–æœ‰ç„¡ä¿®æ­£ï¼Œéƒ½ç›´æ¥å–æœ€æ–°çš„é…ç½®
      const data = {
        total_area: totalArea,
        style: style,
        owner_info: owner_info,
        furniture_layout: window.latestParsedFurniture,
        image_filename: fileInput.files[0].name
      };

      const genRes = await fetch("https://interior-indoortour-ai.onrender.com/api/generate_design_narrative", {
        method: "POST", headers: { "Content-Type": "application/json" }, body: JSON.stringify(data)
      });
      const genData = await genRes.json();

      window.generatedDocPayload = { ...genData, image_filename: fileInput.files[0].name };
      document.getElementById("downloadWord").style.display = "inline-block";

      let previewText = "";
      if (genData.concept) previewText += genData.concept + "\n\n";
      if (Array.isArray(genData.sections)) {
        previewText += genData.sections.map(s => {
          if (s.room) {
            // Wordæ ¼å¼
            return "ã€" + s.room + "ã€‘\n" +
              "åªæ•¸ï¼š" + (s.area || "") + "\n" +
              "åŠŸèƒ½ï¼š" + (s.function || "") + "\n" +
              "å‚¢ä¿±é…ç½®ï¼š" + (Array.isArray(s.furniture) ? s.furniture.join("ã€") : s.furniture || "") + "\n" +
              "è‰²å½©æ­é…ï¼š" + (s.color || "") + "\n" +
              "è¨­è¨ˆé‡é»ï¼š" + (s.design_note || "") + "\n" +
              "æƒ…æ„Ÿæè¿°ï¼š" + (s.emotion || "");
          } else if (s.title && s.text) {
            // èˆŠæ ¼å¼
            return "ã€" + s.title + "ã€‘\n" + s.text;
          }
          return "";
        }).join("\n\n") + "\n\n";
      }
      if (genData.conclusion) previewText += genData.conclusion;
      if (genData.error) {
        document.getElementById("docPreview").innerText = "âŒ éŒ¯èª¤ï¼š" + genData.error;
        return;
      }
      if (!previewText && genData.content) {
        previewText = genData.content;
      }
      document.getElementById("docPreview").innerText = previewText || "âŒ æ–‡æ¡ˆç”¢å‡ºå¤±æ•—æˆ–æ ¼å¼éŒ¯èª¤";
      status.textContent = "âœ… å·²ä¸‹è¼‰ Word æ–‡æ¡ˆå®Œæˆï¼";
    }

    async function downloadWordDoc() {
      const docRes = await fetch("https://interior-indoortour-ai.onrender.com/api/download_word_docx", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(window.generatedDocPayload)
      });
      const blob = await docRes.blob();
      const url = window.URL.createObjectURL(blob);
      const a = document.createElement("a");
      a.href = url;
      a.download = "ç©ºé–“è¨­è¨ˆå°è¦½æ–‡æ¡ˆ.docx";
      a.click();
    }

    function renderFurnitureTable(spaces) {
      let tableHtml = "<h3>ğŸ“‹ å®¶å…·é…ç½®é è¦½</h3><table border='1' cellpadding='6' style='border-collapse:collapse; width:100%; text-align:left;'><thead><tr><th>ç©ºé–“åç¨±</th><th>åªæ•¸</th><th>ä¸»è¦å®¶å…·é…ç½®</th></tr></thead><tbody>";
      spaces.forEach(space => {
        const furnitureList = Array.isArray(space.furniture) ? space.furniture.join("ã€") : "";
        tableHtml += `<tr><td>${space.name}</td><td>${space.area}</td><td>${furnitureList}</td></tr>`;
      });
      tableHtml += "</tbody></table>";
      document.getElementById("furniturePreview").innerHTML = tableHtml;
    }

    function applyFurnitureCorrection() {
      const correctionText = document.getElementById("furniture_correction").value.trim();
      if (!window.latestParsedFurniture || !correctionText) return;

      const updates = correctionText.split("ï¼Œ");
      updates.forEach(update => {
        let space;
        let renameRoom = update.match(/(.+?)æ”¹åç‚º(.+)/);
        if (renameRoom) {
          const from = renameRoom[1].trim();
          const to = renameRoom[2].trim();
          space = window.latestParsedFurniture.find(s => s.name === from);
          if (space) space.name = to;
          return;
        }
        let addRoom = update.match(/æ–°å¢(.+?)\s*([\d.]+)åªï¼Œå®¶å…·[:ï¼š](.+)/);
        if (addRoom) {
          const name = addRoom[1].trim();
          const area = parseFloat(addRoom[2]);
          const furnitureList = addRoom[3].split("ã€").map(f => f.trim());
          window.latestParsedFurniture.push({ name, area, furniture: furnitureList });
          return;
        }
        let delRoom = update.match(/åˆªé™¤(.+?)/);
        if (delRoom) {
          const name = delRoom[1].trim();
          window.latestParsedFurniture = window.latestParsedFurniture.filter(s => s.name !== name);
          return;
        }
        let renameFurniture = update.match(/(.+?)å°‡(.+?)æ”¹ç‚º(.+)/);
        if (renameFurniture) {
          const room = renameFurniture[1].trim();
          const from = renameFurniture[2].trim();
          const to = renameFurniture[3].trim();
          space = window.latestParsedFurniture.find(s => s.name === room);
          if (space) {
            const idx = space.furniture.findIndex(f => f.includes(from));
            if (idx !== -1) space.furniture[idx] = to;
          }
          return;
        }
        let addMatch = update.match(/(.+?)å¢åŠ (.+)/);
        if (addMatch) {
          const roomName = addMatch[1].trim();
          const item = addMatch[2].trim();
          space = window.latestParsedFurniture.find(s => s.name === roomName);
          if (space) space.furniture.push(item);
          return;
        }
        let delMatch = update.match(/(.+?)åˆªé™¤(.+)/);
        if (delMatch) {
          const roomName = delMatch[1].trim();
          const item = delMatch[2].trim();
          space = window.latestParsedFurniture.find(s => s.name === roomName);
          if (space) space.furniture = space.furniture.filter(f => !f.includes(item));
          return;
        }
        let areaMatch = update.match(/(.+?)åªæ•¸æ”¹ç‚º([\d.]+)/);
        if (areaMatch) {
          const roomName = areaMatch[1].trim();
          const newArea = parseFloat(areaMatch[2]);
          space = window.latestParsedFurniture.find(s => s.name === roomName);
          if (space && !isNaN(newArea)) space.area = newArea;
          return;
        }
        let clearMatch = update.match(/(.+?)æ¸…ç©ºå®¶å…·/);
        if (clearMatch) {
          const roomName = clearMatch[1].trim();
          space = window.latestParsedFurniture.find(s => s.name === roomName);
          if (space) space.furniture = [];
          return;
        }
      });

      renderFurnitureTable(window.latestParsedFurniture);
    }
  </script>
</body>
</html>